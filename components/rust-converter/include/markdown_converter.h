/* Auto-generated by cbindgen - DO NOT EDIT MANUALLY */

#ifndef NGINX_MARKDOWN_CONVERTER_H
#define NGINX_MARKDOWN_CONVERTER_H

/* Generated with cbindgen:0.29.2 */

/* Warning: This file is auto-generated by cbindgen. */
/* Any manual changes will be overwritten on next build. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Success - no error occurred
 */
#define ERROR_SUCCESS 0

/**
 * HTML parsing failed (malformed HTML, invalid structure)
 */
#define ERROR_PARSE 1

/**
 * Character encoding error (invalid UTF-8, unsupported charset)
 */
#define ERROR_ENCODING 2

/**
 * Conversion timeout exceeded
 */
#define ERROR_TIMEOUT 3

/**
 * Memory limit exceeded during conversion
 */
#define ERROR_MEMORY_LIMIT 4

/**
 * Invalid input data (NULL pointers, invalid parameters)
 */
#define ERROR_INVALID_INPUT 5

/**
 * Internal error (unexpected condition, panic caught)
 */
#define ERROR_INTERNAL 99

/**
 * Opaque handle to Rust converter instance
 *
 * This is an opaque type that hides the internal Rust implementation
 * from C code. C code receives a pointer to this type but cannot
 * access its internals.
 *
 * # Lifecycle
 *
 * 1. Create: `markdown_converter_new()` returns a handle
 * 2. Use: Pass handle to `markdown_convert()` for conversions
 * 3. Destroy: `markdown_converter_free()` deallocates the handle
 *
 * # Thread Safety
 *
 * **NOT thread-safe** - Each NGINX worker should have its own instance.
 * Do not share handles across threads or concurrent requests.
 *
 * # Example Usage (C)
 *
 * ```c
 * // Create converter
 * markdown_converter_t *converter = markdown_converter_new();
 * if (converter == NULL) {
 *     // Handle allocation failure
 *     return;
 * }
 *
 * // Use converter for multiple conversions
 * markdown_result_t result1, result2;
 * markdown_convert(converter, html1, len1, &options, &result1);
 * markdown_convert(converter, html2, len2, &options, &result2);
 *
 * // Clean up results
 * markdown_result_free(&result1);
 * markdown_result_free(&result2);
 *
 * // Destroy converter
 * markdown_converter_free(converter);
 * ```
 */
typedef struct MarkdownConverterHandle MarkdownConverterHandle;

/**
 * Conversion options passed from C to Rust
 *
 * This structure controls the behavior of the HTML to Markdown conversion.
 * All fields use C-compatible types and layout.
 *
 * # C Compatibility
 *
 * - `#[repr(C)]` ensures C-compatible memory layout
 * - All fields use fixed-size types (u32, u8)
 * - No padding or alignment issues across the boundary
 *
 * # Field Descriptions
 *
 * - `flavor`: Markdown output format
 *   - 0 = CommonMark (default, well-specified baseline)
 *   - 1 = GitHub Flavored Markdown (GFM, adds tables, task lists, etc.)
 *
 * - `timeout_ms`: Maximum conversion time in milliseconds
 *   - 0 = no timeout (not recommended)
 *   - Typical value: 5000 (5 seconds)
 *   - Cooperative timeout (checks periodically, doesn't spawn threads)
 *
 * - `generate_etag`: Whether to generate ETag for caching
 *   - 0 = no ETag generation (faster)
 *   - 1 = generate ETag via BLAKE3 hash of output
 *
 * - `estimate_tokens`: Whether to estimate token count for LLMs
 *   - 0 = no estimation
 *   - 1 = estimate using character count / 4 heuristic
 *
 * - `front_matter`: Whether to include YAML front matter with metadata
 *   - 0 = no front matter
 *   - 1 = include front matter (title, description, etc.)
 *
 * - `content_type`: Optional Content-Type header value for charset detection
 *   - Pointer to UTF-8 string (e.g., "text/html; charset=UTF-8")
 *   - NULL if not available
 *   - If pointer is NULL, `content_type_len` must be 0
 *   - Used for charset detection cascade (FR-05.1)
 *
 * - `content_type_len`: Length of content_type string in bytes
 *   - 0 if content_type is NULL
 *
 * - `base_url`: Optional base URL for resolving relative URLs in HTML
 *   - Pointer to UTF-8 string (e.g., "https://example.com/page")
 *   - NULL if not available
 *   - If pointer is NULL, `base_url_len` must be 0
 *   - Used for metadata extraction and URL resolution
 *   - Format: scheme://host/path (e.g., "https://example.com/docs/page.html")
 *
 * - `base_url_len`: Length of base_url string in bytes
 *   - 0 if base_url is NULL
 *
 * # Example Usage (C)
 *
 * ```c
 * // Without Content-Type or base_url
 * markdown_options_t options = {
 *     .flavor = 0,              // CommonMark
 *     .timeout_ms = 5000,       // 5 second timeout
 *     .generate_etag = 1,       // Generate ETag
 *     .estimate_tokens = 1,     // Estimate tokens
 *     .front_matter = 0,        // No front matter
 *     .content_type = NULL,     // No Content-Type
 *     .content_type_len = 0,
 *     .base_url = NULL,         // No base URL
 *     .base_url_len = 0
 * };
 *
 * // With Content-Type and base_url
 * const char *ct = "text/html; charset=UTF-8";
 * const char *base = "https://example.com/page";
 * markdown_options_t options = {
 *     .flavor = 0,
 *     .timeout_ms = 5000,
 *     .generate_etag = 1,
 *     .estimate_tokens = 1,
 *     .front_matter = 0,
 *     .content_type = (const uint8_t*)ct,
 *     .content_type_len = strlen(ct),
 *     .base_url = (const uint8_t*)base,
 *     .base_url_len = strlen(base)
 * };
 * ```
 *
 * # Safety
 *
 * This struct is safe to pass across the FFI boundary as it contains only
 * plain data types with no pointers or complex ownership.
 */
typedef struct MarkdownOptions {
  /**
   * Markdown flavor: 0=CommonMark, 1=GFM
   */
  uint32_t flavor;
  /**
   * Conversion timeout in milliseconds (0=no timeout)
   */
  uint32_t timeout_ms;
  /**
   * Generate ETag: 0=no, 1=yes
   */
  uint8_t generate_etag;
  /**
   * Estimate tokens: 0=no, 1=yes
   */
  uint8_t estimate_tokens;
  /**
   * Include YAML front matter: 0=no, 1=yes
   */
  uint8_t front_matter;
  /**
   * Content-Type header value for charset detection (UTF-8 bytes, can be NULL)
   */
  const uint8_t *content_type;
  /**
   * Length of content_type in bytes (0 if NULL)
   */
  uintptr_t content_type_len;
  /**
   * Base URL for resolving relative URLs (UTF-8 bytes, can be NULL)
   */
  const uint8_t *base_url;
  /**
   * Length of base_url in bytes (0 if NULL)
   */
  uintptr_t base_url_len;
} MarkdownOptions;

/**
 * Conversion result returned from Rust to C
 *
 * This structure contains the output of HTML to Markdown conversion,
 * including the converted content, metadata, and any errors.
 *
 * # CRITICAL: String Representation
 *
 * **All string fields use UTF-8 bytes + length (NOT NUL-terminated)**
 *
 * String fields follow this pattern:
 * - `markdown`: `*mut u8` pointer to UTF-8 bytes
 * - `markdown_len`: `usize` byte count (NOT including NUL)
 *
 * **C code MUST:**
 * - Use the `_len` fields for all string operations
 * - NOT use `strlen()` on these pointers
 * - NOT assume NUL termination
 *
 * # Memory Ownership
 *
 * **Rust owns all allocated memory:**
 * - On success, `markdown` and `etag` point to Rust-allocated memory
 * - C receives pointers but does NOT own the memory
 * - C MUST call `markdown_result_free()` exactly once to deallocate
 * - After calling free, all pointers become invalid
 * - Do NOT call `free()` directly on these pointers
 *
 * # Field Descriptions
 *
 * ## Output Fields (valid on success)
 *
 * - `markdown`: Pointer to UTF-8 Markdown output bytes
 * - `markdown_len`: Byte length of Markdown output
 * - `etag`: Pointer to UTF-8 ETag string (NULL if not generated)
 * - `etag_len`: Byte length of ETag (0 if NULL)
 * - `token_estimate`: Estimated token count for LLM context windows
 *
 * ## Error Fields (valid on error)
 *
 * - `error_code`: Error code constant (0 = success, see ERROR_* constants)
 * - `error_message`: Pointer to UTF-8 error description (NULL on success)
 * - `error_len`: Byte length of error message (0 if NULL)
 *
 * # State Invariants
 *
 * **Success State (error_code == 0):**
 * - `markdown` is non-NULL and points to valid UTF-8 bytes
 * - `markdown_len` > 0
 * - `etag` may be NULL or point to valid UTF-8 bytes
 * - `etag_len` matches etag content (0 if etag is NULL)
 * - `token_estimate` contains estimated count (or 0 if not requested)
 * - `error_message` is NULL
 * - `error_len` is 0
 *
 * **Error State (error_code != 0):**
 * - `markdown` is NULL
 * - `markdown_len` is 0
 * - `etag` is NULL
 * - `etag_len` is 0
 * - `token_estimate` is 0
 * - `error_message` is non-NULL and points to valid UTF-8 bytes
 * - `error_len` > 0
 *
 * # Example Usage (C)
 *
 * ```c
 * markdown_result_t result;
 * markdown_convert(converter, html, html_len, &options, &result);
 *
 * if (result.error_code == 0) {
 *     // Success - process markdown
 *     for (size_t i = 0; i < result.markdown_len; i++) {
 *         process_byte(result.markdown[i]);
 *     }
 *
 *     // Check for optional ETag
 *     if (result.etag != NULL) {
 *         set_etag_header(result.etag, result.etag_len);
 *     }
 *
 *     // Use token estimate
 *     log_tokens(result.token_estimate);
 * } else {
 *     // Error - log error message
 *     log_error(result.error_code, result.error_message, result.error_len);
 * }
 *
 * // Always free result
 * markdown_result_free(&result);
 * ```
 *
 * # Safety
 *
 * This struct is safe to pass across the FFI boundary, but the pointers
 * it contains require careful handling:
 * - All pointers must be validated before dereferencing
 * - Memory must be freed via `markdown_result_free()`
 * - Pointers become invalid after free
 * - Do not mix Rust and C memory allocators
 */
typedef struct MarkdownResult {
  /**
   * Output Markdown (UTF-8 bytes, NOT NUL-terminated)
   * NULL on error, non-NULL on success
   */
  uint8_t *markdown;
  /**
   * Length of markdown in bytes (NOT including NUL)
   * 0 on error, >0 on success
   */
  uintptr_t markdown_len;
  /**
   * ETag string (UTF-8 bytes, optional, NULL if not generated)
   * NULL if not requested or on error
   */
  uint8_t *etag;
  /**
   * Length of etag in bytes
   * 0 if etag is NULL
   */
  uintptr_t etag_len;
  /**
   * Estimated token count for LLM context windows
   * 0 if not requested or on error
   */
  uint32_t token_estimate;
  /**
   * Error code: 0=success, non-zero=error (see ERROR_* constants)
   */
  uint32_t error_code;
  /**
   * Error message (UTF-8 bytes, NULL if success)
   * Non-NULL on error, NULL on success
   */
  uint8_t *error_message;
  /**
   * Length of error message in bytes
   * 0 if error_message is NULL
   */
  uintptr_t error_len;
} MarkdownResult;

/**
 * Create a new converter instance
 *
 * Allocates and initializes a new Markdown converter that can be used
 * for multiple conversion operations.
 *
 * # Returns
 *
 * - Non-NULL pointer to `MarkdownConverterHandle` on success
 * - NULL on allocation failure
 *
 * # Memory Management
 *
 * The returned handle is owned by the caller and must be freed by calling
 * `markdown_converter_free()` exactly once when no longer needed.
 *
 * # Thread Safety
 *
 * This function is thread-safe. Multiple threads can create their own
 * converter instances concurrently. However, the returned handle is NOT
 * thread-safe and should not be shared across threads.
 *
 * # Example (C)
 *
 * ```c
 * markdown_converter_t *converter = markdown_converter_new();
 * if (converter == NULL) {
 *     fprintf(stderr, "Failed to create converter\n");
 *     return -1;
 * }
 * // Use converter...
 * markdown_converter_free(converter);
 * ```
 *
 * # Safety
 *
 * This function is safe to call from C code. It performs no pointer
 * dereferencing and handles all allocation failures gracefully.
 */
struct MarkdownConverterHandle *markdown_converter_new(void);

/**
 * Perform HTML to Markdown conversion
 *
 * Converts HTML content to Markdown format according to the provided options.
 * This is the main conversion function that C code calls to transform HTML.
 *
 * # Parameters
 *
 * - `handle`: Pointer to converter instance from `markdown_converter_new()`
 *   - Must be non-NULL
 *   - Must be a valid handle (not freed)
 *   - Must not be used concurrently from multiple threads
 *
 * - `html`: Pointer to HTML input bytes
 *   - Must be non-NULL when `html_len > 0`
 *   - Must point to valid memory of at least `html_len` bytes
 *   - May be NULL when `html_len == 0`
 *   - Should be valid UTF-8 (invalid UTF-8 will cause encoding error)
 *   - Content is not modified (read-only)
 *
 * - `html_len`: Length of HTML input in bytes
 *   - Must accurately reflect the size of the html buffer
 *   - Can be 0 (will result in empty output)
 *
 * - `options`: Pointer to conversion options
 *   - Must be non-NULL
 *   - Must point to valid `MarkdownOptions` struct
 *   - Content is not modified (read-only)
 *
 * - `result`: Pointer to result structure to populate
 *   - Must be non-NULL
 *   - Must point to valid `MarkdownResult` struct
 *   - Previous contents are overwritten
 *   - Caller must call `markdown_result_free()` after use
 *
 * # Behavior
 *
 * **On Success:**
 * - `result->error_code` is set to 0
 * - `result->markdown` points to allocated Markdown bytes
 * - `result->markdown_len` contains byte length
 * - `result->etag` may be set if requested
 * - `result->token_estimate` may be set if requested
 * - `result->error_message` is NULL
 *
 * **On Error:**
 * - `result->error_code` is set to non-zero error code
 * - `result->error_message` points to error description
 * - `result->error_len` contains error message length
 * - All output fields (markdown, etag) are NULL
 *
 * # Error Codes
 *
 * - `ERROR_INVALID_INPUT` (5): NULL pointer or invalid parameter
 * - `ERROR_PARSE` (1): HTML parsing failed
 * - `ERROR_ENCODING` (2): Character encoding error
 * - `ERROR_TIMEOUT` (3): Conversion exceeded timeout
 * - `ERROR_MEMORY_LIMIT` (4): Memory limit exceeded
 * - `ERROR_INTERNAL` (99): Internal error or panic caught
 *
 * # Memory Management
 *
 * **Input Memory:**
 * - Caller owns `html` and `options` memory
 * - Function does not modify or free input memory
 * - Input memory can be freed after function returns
 *
 * **Output Memory:**
 * - Function allocates memory for output fields
 * - Caller must call `markdown_result_free()` to deallocate
 * - Do NOT call `free()` directly on result pointers
 *
 * # Panic Safety
 *
 * This function uses `catch_unwind` to prevent Rust panics from unwinding
 * into C code. Any panic is caught and converted to `ERROR_INTERNAL`.
 *
 * # Thread Safety
 *
 * This function is NOT thread-safe with respect to the same `handle`.
 * Do not call this function concurrently on the same handle from multiple
 * threads. Each thread should have its own converter instance.
 *
 * # Example (C)
 *
 * ```c
 * markdown_converter_t *converter = markdown_converter_new();
 * markdown_options_t options = {
 *     .flavor = 0,
 *     .timeout_ms = 5000,
 *     .generate_etag = 1,
 *     .estimate_tokens = 1,
 *     .front_matter = 0
 * };
 *
 * markdown_result_t result;
 * markdown_convert(converter, html, html_len, &options, &result);
 *
 * if (result.error_code == 0) {
 *     // Success - use result.markdown
 *     send_response(result.markdown, result.markdown_len);
 * } else {
 *     // Error - log error message
 *     log_error(result.error_code, result.error_message, result.error_len);
 * }
 *
 * markdown_result_free(&result);
 * markdown_converter_free(converter);
 * ```
 *
 * # Safety
 *
 * **Pointer Validation:**
 * - All pointers are validated for NULL before dereferencing
 * - NULL pointers result in `ERROR_INVALID_INPUT`
 * - Invalid (non-NULL but bad) pointers cause undefined behavior
 *
 * **Memory Safety:**
 * - No buffer overflows (uses Rust's bounds checking)
 * - No use-after-free (ownership model prevents it)
 * - No double-free (memory freed exactly once via result_free)
 *
 * **Undefined Behavior:**
 * - Passing invalid (non-NULL but bad) pointers is undefined behavior
 * - Using a freed handle is undefined behavior
 * - Concurrent calls on same handle is undefined behavior
 * - Not calling `markdown_result_free()` causes memory leak (not UB)
 */
void markdown_convert(struct MarkdownConverterHandle *handle,
                      const uint8_t *html,
                      uintptr_t html_len,
                      const struct MarkdownOptions *options,
                      struct MarkdownResult *result);

/**
 * Free memory allocated by conversion result
 *
 * Deallocates all memory associated with a `MarkdownResult` structure.
 * This function must be called exactly once for each successful or failed
 * conversion to prevent memory leaks.
 *
 * # Parameters
 *
 * - `result`: Pointer to result structure to free
 *   - Must be non-NULL
 *   - Must point to valid `MarkdownResult` struct
 *   - Must have been populated by `markdown_convert()`
 *   - Must not have been freed previously
 *
 * # Behavior
 *
 * This function:
 * 1. Frees `markdown` memory if non-NULL
 * 2. Frees `etag` memory if non-NULL
 * 3. Frees `error_message` memory if non-NULL
 * 4. Sets all pointers to NULL
 * 5. Sets all lengths to 0
 *
 * After calling this function, all pointers in the result become invalid
 * and must not be dereferenced.
 *
 * # Idempotency
 *
 * This function is safe to call multiple times on the same result
 * (though not recommended). After the first call, all pointers are NULL,
 * so subsequent calls are no-ops.
 *
 * # Memory Management
 *
 * **CRITICAL:** This function uses Rust's memory allocator to free memory.
 * Do NOT call C's `free()` on these pointers - it will cause undefined
 * behavior due to allocator mismatch.
 *
 * **Memory Deallocation Strategy:**
 * - `markdown` and `etag`: Allocated as `Box<[u8]>`, freed using `Box::from_raw(slice::from_raw_parts_mut())`
 * - `error_message`: Allocated as `Box<[u8]>`, freed using `Box::from_raw(slice::from_raw_parts_mut())`
 * - **NEVER use CString::from_raw() for markdown/etag fields** - they are NOT NUL-terminated C strings
 *
 * # Example (C)
 *
 * ```c
 * markdown_result_t result;
 * markdown_convert(converter, html, html_len, &options, &result);
 *
 * // Use result...
 * if (result.error_code == 0) {
 *     process_markdown(result.markdown, result.markdown_len);
 * }
 *
 * // Always free, even on error
 * markdown_result_free(&result);
 *
 * // After free, pointers are invalid
 * // result.markdown is now NULL and must not be used
 * ```
 *
 * # Safety
 *
 * **Pointer Validation:**
 * - NULL `result` pointer is handled gracefully (no-op)
 * - NULL pointers within result are handled gracefully (no-op)
 *
 * **Memory Safety:**
 * - Uses Rust's `Box::from_raw()` to reconstruct and drop allocations
 * - Prevents double-free by setting pointers to NULL after freeing
 * - Safe to call multiple times (idempotent)
 *
 * **Undefined Behavior:**
 * - Passing invalid (non-NULL but bad) pointer is undefined behavior
 * - Freeing a result that wasn't populated by `markdown_convert()` is UB
 * - Mixing Rust and C allocators (calling C `free()`) is UB
 */
void markdown_result_free(struct MarkdownResult *result);

/**
 * Destroy converter instance
 *
 * Deallocates a converter instance created by `markdown_converter_new()`.
 * This function must be called exactly once when the converter is no longer
 * needed to prevent memory leaks.
 *
 * # Parameters
 *
 * - `handle`: Pointer to converter instance
 *   - Must be non-NULL
 *   - Must be a valid handle from `markdown_converter_new()`
 *   - Must not have been freed previously
 *   - Must not be in use by concurrent operations
 *
 * # Behavior
 *
 * This function:
 * 1. Deallocates the converter instance
 * 2. Invalidates the handle pointer
 *
 * After calling this function, the handle pointer becomes invalid and
 * must not be used for any further operations.
 *
 * # Lifecycle
 *
 * This is the final step in the converter lifecycle:
 * 1. Create: `markdown_converter_new()`
 * 2. Use: `markdown_convert()` (can be called multiple times)
 * 3. Destroy: `markdown_converter_free()` (call once)
 *
 * # Memory Management
 *
 * **CRITICAL:** This function uses Rust's memory allocator to free memory.
 * Do NOT call C's `free()` on the handle - it will cause undefined
 * behavior due to allocator mismatch.
 *
 * # Example (C)
 *
 * ```c
 * markdown_converter_t *converter = markdown_converter_new();
 *
 * // Use converter for multiple conversions
 * markdown_result_t result1, result2;
 * markdown_convert(converter, html1, len1, &options, &result1);
 * markdown_convert(converter, html2, len2, &options, &result2);
 *
 * // Free results
 * markdown_result_free(&result1);
 * markdown_result_free(&result2);
 *
 * // Destroy converter
 * markdown_converter_free(converter);
 *
 * // After free, converter pointer is invalid
 * // Do not use converter for any further operations
 * ```
 *
 * # Safety
 *
 * **Pointer Validation:**
 * - NULL handle is handled gracefully (no-op)
 *
 * **Memory Safety:**
 * - Uses Rust's `Box::from_raw()` to reconstruct and drop allocation
 * - Prevents double-free (caller responsibility to call only once)
 *
 * **Undefined Behavior:**
 * - Passing invalid (non-NULL but bad) pointer is undefined behavior
 * - Freeing a handle that wasn't created by `markdown_converter_new()` is UB
 * - Using handle after free is undefined behavior
 * - Freeing handle while conversion is in progress is undefined behavior
 * - Mixing Rust and C allocators (calling C `free()`) is UB
 */
void markdown_converter_free(struct MarkdownConverterHandle *handle);

#endif  /* NGINX_MARKDOWN_CONVERTER_H */
